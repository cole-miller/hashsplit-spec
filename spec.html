<h1 id="introduction">Introduction</h1>
<p>This specification describes a mechanism for splitting a byte stream into blocks of varying size with split boundaries based solely on the content of the input. It also describes a mechanism for organizing those blocks into a (probabilistically) balanced tree whose shape is likewise determined solely by the content of the input.</p>
<p>The general technique has been used by various systems such as:</p>
<ul>
<li><a href="https://perkeep.org">Perkeep</a></li>
<li><a href="https://bup.github.io/">Bup</a></li>
<li><a href="https://rsync.samba.org/">RSync</a></li>
<li><a href="https://pdos.csail.mit.edu/papers/lbfs:sosp01/lbfs.pdf">Low-Bandwidth Network Filesystem (LBFS)</a></li>
<li><a href="https://syncthing.net/">Syncthing</a></li>
<li><a href="https://github.com/kopia/kopia">Kopia</a></li>
</ul>
<p>...and many others. The technique permits the efficient representation of slightly different versions of the same data (e.g. successive revisions of a file in a version control system), since changes in one part of the input generally do not affect the boundaries of any but the adjacent blocks.</p>
<p>However, the exact functions used by these systems differ in details, and thus do not produce identical splits, making interoperability for some use cases more difficult than it should be.</p>
<p>The role of this specification is therefore to fully and formally describe a concrete function on which future systems may standardize, improving interoperability.</p>
<h1 id="notation">Notation</h1>
<p>This section discusses notation used in this specification.</p>
<p>We define the following sets:</p>
<ul>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>U</mi><mn>32</mn></msub><annotation encoding="application/x-tex">U_{32}</annotation></semantics></math>, The set of integers in the range <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><msup><mn>2</mn><mn>32</mn></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">[0, 2^{32})</annotation></semantics></math></li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>U</mi><mn>8</mn></msub><annotation encoding="application/x-tex">U_8</annotation></semantics></math>, The set of integers in the range <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><msup><mn>2</mn><mn>8</mn></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">[0, 2^8)</annotation></semantics></math>, aka bytes.</li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>V</mi><mn>8</mn></msub><annotation encoding="application/x-tex">V_8</annotation></semantics></math>, The set of <em>sequences</em> of bytes, i.e. sequences of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>U</mi><mn>8</mn></msub><annotation encoding="application/x-tex">U_8</annotation></semantics></math>.</li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>V</mi><mi>v</mi></msub><annotation encoding="application/x-tex">V_v</annotation></semantics></math>, The set of <em>sequences</em> of <em>sequences</em> of bytes, i.e. sequences of elements of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>V</mi><mn>8</mn></msub><annotation encoding="application/x-tex">V_8</annotation></semantics></math>.</li>
</ul>
<p>All arithmetic operations in this document are implicitly performed modulo <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>2</mn><mn>32</mn></msup><annotation encoding="application/x-tex">2^{32}</annotation></semantics></math>. We use standard mathematical notation for addition, subtraction, multiplication, and exponentiation. Division always denotes integer division, i.e. any remainder is dropped.</p>
<p>We use the notation <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">⟨</mo><msub><mi>X</mi><mn>0</mn></msub><mo>,</mo><msub><mi>X</mi><mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>X</mi><mi>k</mi></msub><mo stretchy="false" form="postfix">⟩</mo></mrow><annotation encoding="application/x-tex">\langle X_0, X_1, \dots, X_k \rangle</annotation></semantics></math> to denote an ordered sequence of values.</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">|</mo><mi>X</mi><mo stretchy="false" form="prefix">|</mo></mrow><annotation encoding="application/x-tex">|X|</annotation></semantics></math> denotes the length of the sequence <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi><annotation encoding="application/x-tex">X</annotation></semantics></math>, i.e. the number of elements it contains.</p>
<p>We also use the following operators and functions:</p>
<ul>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∧</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x \wedge y</annotation></semantics></math> denotes the bitwise AND of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math></li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∨</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x \vee y</annotation></semantics></math> denotes the bitwise OR of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math></li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>≪</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">x \ll n</annotation></semantics></math> denotes shifting <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> to the left <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> bits, i.e. <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>≪</mo><mi>n</mi><mo>=</mo><mi>x</mi><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">x \ll n = x2^{n}</annotation></semantics></math></li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>≫</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">x \gg n</annotation></semantics></math> denotes a <em>logical</em> right shift -- it shifts <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> to the right by <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> bits, i.e. <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>≫</mo><mi>n</mi><mo>=</mo><mi>x</mi><mi>/</mi><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">x \gg n = x / 2^n</annotation></semantics></math></li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>∥</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X \mathbin{\|} Y</annotation></semantics></math> denotes the concatenation of two sequences <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi><annotation encoding="application/x-tex">X</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Y</mi><annotation encoding="application/x-tex">Y</annotation></semantics></math>, i.e. if <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>=</mo><mo stretchy="false" form="prefix">⟨</mo><msub><mi>X</mi><mn>0</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>X</mi><mi>N</mi></msub><mo stretchy="false" form="postfix">⟩</mo></mrow><annotation encoding="application/x-tex">X = \langle X_0, \dots, X_N \rangle</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi><mo>=</mo><mo stretchy="false" form="prefix">⟨</mo><msub><mi>Y</mi><mn>0</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>Y</mi><mi>M</mi></msub><mo stretchy="false" form="postfix">⟩</mo></mrow><annotation encoding="application/x-tex">Y = \langle Y_0,  \dots, Y_M \rangle</annotation></semantics></math> then <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>∥</mo><mi>Y</mi><mo>=</mo><mo stretchy="false" form="prefix">⟨</mo><msub><mi>X</mi><mn>0</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>X</mi><mi>N</mi></msub><mo>,</mo><msub><mi>Y</mi><mn>0</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>Y</mi><mi>M</mi></msub><mo stretchy="false" form="postfix">⟩</mo></mrow><annotation encoding="application/x-tex">X \mathbin{\|} Y = \langle X_0, \dots, X_N, Y_0, \dots, Y_M  \rangle</annotation></semantics></math></li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>min</mo><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\min(x, y)</annotation></semantics></math> denotes the minimum of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math>.</li>
</ul>
<h1 id="splitting">Splitting</h1>
<p>The primary result of this specification is to define a family of functions:</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>SPLIT</mo><mi>C</mi></msub><mo>∈</mo><msub><mi>V</mi><mn>8</mn></msub><mo>→</mo><msub><mi>V</mi><mi>v</mi></msub></mrow><annotation encoding="application/x-tex">\operatorname{SPLIT}_C \in V_8 \rightarrow V_v</annotation></semantics></math></p>
<p>...which is parameterized by a configuration <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>C</mi><annotation encoding="application/x-tex">C</annotation></semantics></math>, consisting of:</p>
<ul>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mtext mathvariant="normal">min</mtext></msub><mo>∈</mo><msub><mi>U</mi><mn>32</mn></msub></mrow><annotation encoding="application/x-tex">S_{\text{min}} \in U_{32}</annotation></semantics></math>, the minimum split size</li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mtext mathvariant="normal">max</mtext></msub><mo>∈</mo><msub><mi>U</mi><mn>32</mn></msub></mrow><annotation encoding="application/x-tex">S_{\text{max}} \in U_{32}</annotation></semantics></math>, the maximum split size</li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mo>∈</mo><msub><mi>V</mi><mn>8</mn></msub><mo>→</mo><msub><mi>U</mi><mn>32</mn></msub></mrow><annotation encoding="application/x-tex">H \in V_8 \rightarrow U_{32}</annotation></semantics></math>, the hash function</li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi><mo>∈</mo><msub><mi>U</mi><mn>32</mn></msub></mrow><annotation encoding="application/x-tex">W \in U_{32}</annotation></semantics></math>, the window size</li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo>∈</mo><msub><mi>U</mi><mn>32</mn></msub></mrow><annotation encoding="application/x-tex">T \in U_{32}</annotation></semantics></math>, the threshold</li>
</ul>
<p>The configuration must satisfy <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mtext mathvariant="normal">max</mtext></msub><mo>≥</mo><msub><mi>S</mi><mtext mathvariant="normal">min</mtext></msub><mo>≥</mo><mi>W</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">S_{\text{max}} \ge S_{\text{min}} \ge W &gt; 0</annotation></semantics></math>.</p>
<h2 id="definitions">Definitions</h2>
<p>The &quot;split index&quot; <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><mo stretchy="false" form="prefix">(</mo><mi>X</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">I(X)</annotation></semantics></math>, is either the smallest integer <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math> satisfying:</p>
<ul>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>&lt;</mo><mo stretchy="false" form="prefix">|</mo><mi>X</mi><mo stretchy="false" form="prefix">|</mo></mrow><annotation encoding="application/x-tex">i &lt; |X|</annotation></semantics></math> and</li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mtext mathvariant="normal">max</mtext></msub><mo>≥</mo><mi>i</mi><mo>≥</mo><msub><mi>S</mi><mtext mathvariant="normal">min</mtext></msub></mrow><annotation encoding="application/x-tex">S_{\text{max}} \ge i \ge S_{\text{min}}</annotation></semantics></math> and</li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mo stretchy="false" form="prefix">(</mo><mo stretchy="false" form="prefix">⟨</mo><msub><mi>X</mi><mrow><mi>i</mi><mo>−</mo><mi>W</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>X</mi><mi>i</mi></msub><mo stretchy="false" form="postfix">⟩</mo><mo stretchy="false" form="postfix">)</mo><mo>mod</mo><msup><mn>2</mn><mi>T</mi></msup><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">H(\langle X_{i-W+1}, \dots, X_i \rangle) \mod 2^T = 0</annotation></semantics></math></li>
</ul>
<p>...or <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>min</mo><mo stretchy="false" form="prefix">(</mo><mo stretchy="false" form="prefix">|</mo><mi>X</mi><mo stretchy="false" form="prefix">|</mo><mo>−</mo><mn>1</mn><mo>,</mo><msub><mi>S</mi><mtext mathvariant="normal">max</mtext></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\min(|X| - 1, S_{\text{max}})</annotation></semantics></math>, if no such <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math> exists.</p>
<p>We define <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>SPLIT</mo><mi>C</mi></msub><mo stretchy="false" form="prefix">(</mo><mi>X</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{SPLIT}_C(X)</annotation></semantics></math> recursively, as follows:</p>
<ul>
<li>If <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">|</mo><mi>X</mi><mo stretchy="false" form="prefix">|</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">|X| = 0</annotation></semantics></math>, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>SPLIT</mo><mi>C</mi></msub><mo stretchy="false" form="prefix">(</mo><mi>X</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mo stretchy="false" form="prefix">⟨</mo><mo stretchy="false" form="postfix">⟩</mo></mrow><annotation encoding="application/x-tex">\operatorname{SPLIT}_C(X) = \langle \rangle</annotation></semantics></math></li>
<li>Otherwise, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>SPLIT</mo><mi>C</mi></msub><mo stretchy="false" form="prefix">(</mo><mi>X</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mo stretchy="false" form="prefix">⟨</mo><mi>Y</mi><mo stretchy="false" form="postfix">⟩</mo><mo>∥</mo><msub><mo>SPLIT</mo><mi>C</mi></msub><mo stretchy="false" form="prefix">(</mo><mi>Z</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{SPLIT}_C(X) = \langle Y \rangle \mathbin{\|}  \operatorname{SPLIT}_C(Z)</annotation></semantics></math> where</li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mi>I</mi><mo stretchy="false" form="prefix">(</mo><mi>X</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">i = I(X)</annotation></semantics></math></li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>=</mo><mo stretchy="false" form="prefix">|</mo><mi>X</mi><mo stretchy="false" form="prefix">|</mo><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">N = |X| - 1</annotation></semantics></math></li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi><mo>=</mo><mo stretchy="false" form="prefix">⟨</mo><msub><mi>X</mi><mn>0</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>X</mi><mi>i</mi></msub><mo stretchy="false" form="postfix">⟩</mo></mrow><annotation encoding="application/x-tex">Y = \langle X_0, \dots, X_i \rangle</annotation></semantics></math></li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Z</mi><mo>=</mo><mo stretchy="false" form="prefix">⟨</mo><msub><mi>X</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>X</mi><mi>N</mi></msub><mo stretchy="false" form="postfix">⟩</mo></mrow><annotation encoding="application/x-tex">Z = \langle X_{i+1}, \dots, X_N \rangle</annotation></semantics></math></li>
</ul>
<h1 id="tree-construction">Tree Construction</h1>
<p>TODO</p>
<h1 id="rolling-hash-functions">Rolling Hash Functions</h1>
<h2 id="the-rrs-rolling-checksums">The RRS Rolling Checksums</h2>
<p>The <code>rrs</code> family of checksums is based on an algorithm first used in <a href="https://rsync.samba.org/tech_report/node3.html">rsync</a>, and later adapted for use in <a href="https://bup.github.io/">bup</a> and <a href="https://perkeep.org/">perkeep</a>. <code>rrs</code> was originally inspired by the adler-32 checksum. The name <code>rrs</code> was chosen for this specification, and stands for <code>rsync rolling sum</code>.</p>
<h3 id="definition">Definition</h3>
<p>A concrete <code>rrs</code> checksum is defined by the parameters:</p>
<ul>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math>, the modulus</li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>, the character offset</li>
</ul>
<p>Given a sequence of bytes <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">⟨</mo><msub><mi>X</mi><mn>0</mn></msub><mo>,</mo><msub><mi>X</mi><mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>X</mi><mi>N</mi></msub><mo stretchy="false" form="postfix">⟩</mo></mrow><annotation encoding="application/x-tex">\langle X_0, X_1, \dots, X_N \rangle</annotation></semantics></math> and a choice of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>, the <code>rrs</code> hash of the sub-sequence <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">⟨</mo><msub><mi>X</mi><mi>k</mi></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>X</mi><mi>l</mi></msub><mo stretchy="false" form="postfix">⟩</mo></mrow><annotation encoding="application/x-tex">\langle X_k, \dots, X_l \rangle</annotation></semantics></math> is <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo stretchy="false" form="prefix">(</mo><mi>k</mi><mo>,</mo><mi>l</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">s(k, l)</annotation></semantics></math>, where:</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo stretchy="false" form="prefix">(</mo><mi>k</mi><mo>,</mo><mi>l</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mo stretchy="false" form="prefix">(</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mi>k</mi></mrow><mi>l</mi></msubsup><mo stretchy="false" form="prefix">(</mo><msub><mi>X</mi><mi>i</mi></msub><mo>+</mo><mi>c</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo><mo>mod</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">a(k, l) = (\sum_{i = k}^{l} (X_i + c)) \mod M</annotation></semantics></math></p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo stretchy="false" form="prefix">(</mo><mi>k</mi><mo>,</mo><mi>l</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mo stretchy="false" form="prefix">(</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mi>k</mi></mrow><mi>l</mi></msubsup><mo stretchy="false" form="prefix">(</mo><mi>l</mi><mo>−</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="prefix">(</mo><msub><mi>X</mi><mi>i</mi></msub><mo>+</mo><mi>c</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo><mo>mod</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">b(k, l) = (\sum_{i = k}^{l} (l - i + 1)(X_i + c)) \mod M</annotation></semantics></math></p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo stretchy="false" form="prefix">(</mo><mi>k</mi><mo>,</mo><mi>l</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>b</mi><mo stretchy="false" form="prefix">(</mo><mi>k</mi><mo>,</mo><mi>l</mi><mo stretchy="false" form="postfix">)</mo><mo>+</mo><msup><mn>2</mn><mn>16</mn></msup><mi>a</mi><mo stretchy="false" form="prefix">(</mo><mi>k</mi><mo>,</mo><mi>l</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">s(k, l) = b(k, l) + 2^{16}a(k, l)</annotation></semantics></math></p>
<h4 id="rrs1">RRS1</h4>
<p>The concrete hash called <code>rrs1</code> uses the values:</p>
<ul>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>=</mo><msup><mn>2</mn><mn>16</mn></msup></mrow><annotation encoding="application/x-tex">M = 2^{16}</annotation></semantics></math></li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo>=</mo><mn>31</mn></mrow><annotation encoding="application/x-tex">c = 31</annotation></semantics></math></li>
</ul>
<p><code>rrs1</code> is used by both Bup and Perkeep, and implemented by the Go package <code>go4.org/rollsum</code>.</p>
<h3 id="implementation">Implementation</h3>
<h4 id="rolling">Rolling</h4>
<p><code>rrs</code> is a family of <em>rolling</em> hashes. We can compute hashes in a rolling fashion by taking advantage of the fact that:</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo stretchy="false" form="prefix">(</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo>,</mo><mi>l</mi><mo>+</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo stretchy="false" form="prefix">(</mo><mi>k</mi><mo>,</mo><mi>l</mi><mo stretchy="false" form="postfix">)</mo><mo>−</mo><mo stretchy="false" form="prefix">(</mo><msub><mi>X</mi><mi>k</mi></msub><mo>+</mo><mi>c</mi><mo stretchy="false" form="postfix">)</mo><mo>+</mo><mo stretchy="false" form="prefix">(</mo><msub><mi>X</mi><mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>+</mo><mi>c</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo><mo>mod</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">a(k + 1, l + 1) = (a(k, l) - (X_k + c) + (X_{l+1} + c)) \mod M</annotation></semantics></math></p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo stretchy="false" form="prefix">(</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo>,</mo><mi>l</mi><mo>+</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mo stretchy="false" form="prefix">(</mo><mi>b</mi><mo stretchy="false" form="prefix">(</mo><mi>k</mi><mo>,</mo><mi>l</mi><mo stretchy="false" form="postfix">)</mo><mo>−</mo><mo stretchy="false" form="prefix">(</mo><mi>l</mi><mo>−</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="prefix">(</mo><msub><mi>X</mi><mi>k</mi></msub><mo>+</mo><mi>c</mi><mo stretchy="false" form="postfix">)</mo><mo>+</mo><mi>a</mi><mo stretchy="false" form="prefix">(</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo>,</mo><mi>l</mi><mo>+</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo><mo>mod</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">b(k + 1, l + 1) = (b(k, l) - (l - k + 1)(X_k + c) + a(k + 1, l + 1)) \mod M</annotation></semantics></math></p>
<p>So, a typical implementation will work like this:</p>
<ul>
<li>Keep <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">⟨</mo><msub><mi>X</mi><mi>k</mi></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>X</mi><mi>l</mi></msub><mo stretchy="false" form="postfix">⟩</mo></mrow><annotation encoding="application/x-tex">\langle X_k, \dots, X_l \rangle</annotation></semantics></math> in a ring buffer.</li>
<li>Also store <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo stretchy="false" form="prefix">(</mo><mi>k</mi><mo>,</mo><mi>l</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">a(k, l)</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo stretchy="false" form="prefix">(</mo><mi>k</mi><mo>,</mo><mi>l</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">b(k, l)</annotation></semantics></math>.</li>
<li>When <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>X</mi><mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow></msub><annotation encoding="application/x-tex">X_{l+1}</annotation></semantics></math> is added to the hash:</li>
<li>Dequeue <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>X</mi><mi>k</mi></msub><annotation encoding="application/x-tex">X_k</annotation></semantics></math> from the ring buffer, and enqueue <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>X</mi><mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow></msub><annotation encoding="application/x-tex">X_{l+1}</annotation></semantics></math>.</li>
<li>Use <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>X</mi><mi>k</mi></msub><annotation encoding="application/x-tex">X_k</annotation></semantics></math>, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>X</mi><mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow></msub><annotation encoding="application/x-tex">X_{l+1}</annotation></semantics></math>, and the stored <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo stretchy="false" form="prefix">(</mo><mi>k</mi><mo>,</mo><mi>l</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">a(k, l)</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo stretchy="false" form="prefix">(</mo><mi>k</mi><mo>,</mo><mi>l</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">b(k, l)</annotation></semantics></math> to compute <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo stretchy="false" form="prefix">(</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo>,</mo><mi>l</mi><mo>+</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">a(k + 1, l + 1)</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo stretchy="false" form="prefix">(</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo>,</mo><mi>l</mi><mo>+</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">b(k + 1, l + 1)</annotation></semantics></math>. Then use those values to compute <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo stretchy="false" form="prefix">(</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo>,</mo><mi>l</mi><mo>+</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">s(k + 1, l + 1)</annotation></semantics></math> and also store them for future use.</li>
</ul>
<h4 id="choice-of-m">Choice of M</h4>
<p>Choosing <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>=</mo><msup><mn>2</mn><mn>16</mn></msup></mrow><annotation encoding="application/x-tex">M = 2^{16}</annotation></semantics></math> has the advantages of simplicity and efficiency, as it allows <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo stretchy="false" form="prefix">(</mo><mi>k</mi><mo>,</mo><mi>l</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">s(k, l)</annotation></semantics></math> to be computed using only shifts and bitwise operators:</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo stretchy="false" form="prefix">(</mo><mi>k</mi><mo>,</mo><mi>l</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>b</mi><mo stretchy="false" form="prefix">(</mo><mi>k</mi><mo>,</mo><mi>l</mi><mo stretchy="false" form="postfix">)</mo><mo>∨</mo><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo stretchy="false" form="prefix">(</mo><mi>k</mi><mo>,</mo><mi>l</mi><mo stretchy="false" form="postfix">)</mo><mo>≪</mo><mn>16</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">s(k, l) = b(k, l) \vee (a(k, l) \ll 16)</annotation></semantics></math></p>
